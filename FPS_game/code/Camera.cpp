//code written by Deangeli Gomes Neves
#include "Camera.h"
#include <iostream>

using namespace std;

Camera::Camera() //default constructor
{
    for(int i=0;i<3;i++){
		this->eyeCoordinates[i] = 0;
		this->objectCoordinates[i] = 0;
		this->upVectors[i] = 0;
	}
	this->viewerMatrix = glm::mat4(0.0);
}

void Camera::recvCamera(Camera camera){//"copy and paste" the parameters from another camera 
	this->eyeCoordinates[0] = camera.getEyeCoordinate(0);
	this->eyeCoordinates[1] = camera.getEyeCoordinate(1);
	this->eyeCoordinates[2] = camera.getEyeCoordinate(2);
	
	this->objectCoordinates[0] = camera.getObjectCoordinate(0);
	this->objectCoordinates[1] = camera.getObjectCoordinate(1);
	this->objectCoordinates[2] = camera.getObjectCoordinate(2);
	
	this->upVectors[0] = camera.getUpVector(0);
	this->upVectors[1] = camera.getUpVector(1);
	this->upVectors[2] = camera.getUpVector(2);

	this->updateViewerMatrix();

}

//constructor 
Camera::Camera(GLfloat eye_X, GLfloat eye_Y, GLfloat eye_Z, GLfloat obj_X, GLfloat obj_Y, GLfloat obj_Z,GLint up_X,GLint up_Y,GLint up_Z){
	this->eyeCoordinates[0] = eye_X;
	this->eyeCoordinates[1] = eye_Y;
	this->eyeCoordinates[2] = eye_Z;
	
	this->objectCoordinates[0] = obj_X;
	this->objectCoordinates[1] = obj_Y;
	this->objectCoordinates[2] = obj_Z;
	
	this->upVectors[0] = up_X;
	this->upVectors[1] = up_Y;
	this->upVectors[2] = up_Z;
	
	//generate the view matrix using glm::lookat
	this->viewerMatrix = glm::lookAt(glm::vec3(this->eyeCoordinates[0],this->eyeCoordinates[1],this->eyeCoordinates[2]),
	 glm::vec3(this->objectCoordinates[0],this->objectCoordinates[1],this->objectCoordinates[2]), 
	 glm::vec3(this->upVectors[0],this->upVectors[1],this->upVectors[2]));
}

void Camera::setEyeCoordinates(GLfloat eye_X, GLfloat eye_Y, GLfloat eye_Z){
	this->eyeCoordinates[0] = eye_X;
	this->eyeCoordinates[1] = eye_Y;
	this->eyeCoordinates[2] = eye_Z;
}

void Camera::setObjectCoordinates(GLfloat obj_X, GLfloat obj_Y, GLfloat obj_Z){
	this->objectCoordinates[0] = obj_X;
	this->objectCoordinates[1] = obj_Y;
	this->objectCoordinates[2] = obj_Z;
}

void Camera::setUpVectors(GLint up_X,GLint up_Y,GLint up_Z){
	this->upVectors[0] = up_X;
	this->upVectors[1] = up_Y;
	this->upVectors[2] = up_Z;
}


//update all camera parameters;
void Camera::updateCameraParameters(GLfloat eye_X, GLfloat eye_Y, GLfloat eye_Z, GLfloat obj_X, GLfloat obj_Y, GLfloat obj_Z,GLint up_X,GLint up_Y,GLint up_Z){
	this->eyeCoordinates[0] = eye_X;
	this->eyeCoordinates[1] = eye_Y;
	this->eyeCoordinates[2] = eye_Z;
	
	this->objectCoordinates[0] = obj_X;
	this->objectCoordinates[1] = obj_Y;
	this->objectCoordinates[2] = obj_Z;
	
	this->upVectors[0] = up_X;
	this->upVectors[1] = up_Y;
	this->upVectors[2] = up_Z;
}

//update view matrix
void Camera::updateViewerMatrix(){
		this->viewerMatrix = glm::lookAt( glm::vec3(this->eyeCoordinates[0],this->eyeCoordinates[1],this->eyeCoordinates[2]),
		glm::vec3(this->objectCoordinates[0],this->objectCoordinates[1],this->objectCoordinates[2]), 
		glm::vec3(this->upVectors[0],this->upVectors[1],this->upVectors[2]) );
}

glm::mat4 Camera::getViewerMatrix(){
	return this->viewerMatrix;
}

GLfloat* Camera::getEyeCoordinates(){
	return this->eyeCoordinates;
}

GLfloat* Camera::getObjectCoordinates(){
	return this->objectCoordinates;
}

GLint* Camera::getUpVectors(){
	return this->upVectors;
}

GLfloat Camera::getEyeCoordinate(int index){
	return this->eyeCoordinates[index];
}

GLfloat Camera::getObjectCoordinate(int index){
	return this->objectCoordinates[index];
}

GLint Camera::getUpVector(int index){
	return this->upVectors[index];
}
//update the object coordinates based on the sphere coordinates that were generated by the mouse motion
void Camera::cameraMotion(glm::vec3 objectCoordinatesInSphere){
	this->objectCoordinates[0] = this->eyeCoordinates[0] + objectCoordinatesInSphere.x;
	this->objectCoordinates[1] = this->eyeCoordinates[1] + objectCoordinatesInSphere.y;
	this->objectCoordinates[2] = this->eyeCoordinates[2] + objectCoordinatesInSphere.z;
	
}

//update only the car-camera object-coordinates based on the sphere coordinates that were generated by the mouse motion
//and check if the coordinates are inside the skybox. the parameters of the skybox edges are in limitsP and limitsN
void Camera::cameraMotionCar(glm::vec3 objectCoordinatesInSphere,float radius, float theshold, glm::vec3 limitsP, glm::vec3 limitsN){
	this->objectCoordinates[0] = this->eyeCoordinates[0] + objectCoordinatesInSphere.x*radius;
	this->objectCoordinates[1] = this->eyeCoordinates[1] + objectCoordinatesInSphere.y*radius;
	this->objectCoordinates[2] = this->eyeCoordinates[2] + objectCoordinatesInSphere.z*radius;
	
	if(this->objectCoordinates[0] >= limitsP.x-theshold){
		this->objectCoordinates[0] >= limitsP.x-theshold;
	}
	
	if(this->objectCoordinates[0] <= limitsN.x-theshold){
		this->objectCoordinates[0] <= limitsN.x-theshold;
	}
	
	
	if(this->objectCoordinates[1] >= limitsP.y-theshold){
		this->objectCoordinates[1] >= limitsP.y-theshold;
	}
	
	if(this->objectCoordinates[1] <= limitsN.y+theshold){
		this->objectCoordinates[1] <= limitsN.y+theshold;
	}
	
	if(this->objectCoordinates[2] >= limitsP.x-theshold){
		this->objectCoordinates[2] >= limitsP.x-theshold;
	}
	
	if(this->objectCoordinates[2] <= limitsN.x+theshold){
		this->objectCoordinates[2] <= limitsN.x+theshold;
	}
	
	
}
//print the camera parameters
void Camera::cameraPrint(){
	cout << "eye: " <<  this->eyeCoordinates[0] << " " << this->eyeCoordinates[1] << " " << this->eyeCoordinates[2] << endl;
	cout << "obj: " <<  this->objectCoordinates[0] << " " << this->objectCoordinates[1] << " " << this->objectCoordinates[2] << endl;
	cout << "UpV: " <<  this->upVectors[0] << " " << this->upVectors[1] << " " << this->upVectors[2] << endl;
} 

void Camera::setEyeCoordinates(glm::vec3 _eyeCoordinates){
	this->eyeCoordinates[0] = _eyeCoordinates.x;
	this->eyeCoordinates[1] = _eyeCoordinates.y;
	this->eyeCoordinates[2] = _eyeCoordinates.z;
}

void Camera::setObjCoordinates(glm::vec3 _objCoordinates){
	this->objectCoordinates[0] = _objCoordinates.x;
	this->objectCoordinates[1] = _objCoordinates.y;
	this->objectCoordinates[2] = _objCoordinates.z;
}

//update eyeCoordinates based on another eyeCoordinates 
//and check if the coordinates are inside the skybox. the parameters of the skybox edges are in limitsP and limitsN
void Camera::addEyeCoordinates(glm::vec3 _eyeCoordinates, glm::vec3 cubeLimitP,glm::vec3 cubeLimitN, float theshold ){
	this->eyeCoordinates[0] = _eyeCoordinates.x + eyeCoordinates[0];
	this->eyeCoordinates[1] = _eyeCoordinates.y + eyeCoordinates[1];
	this->eyeCoordinates[2] = _eyeCoordinates.z + eyeCoordinates[2];
	
	if(this->eyeCoordinates[0] >= cubeLimitP.x - theshold){
		this->eyeCoordinates[0] = cubeLimitP.x - 1;
	}
	
	if(this->eyeCoordinates[1] >= cubeLimitP.y  - theshold){
		
		this->eyeCoordinates[1] = cubeLimitP.y - 1;
	}
	
	if(this->eyeCoordinates[2] >= cubeLimitP.z  - theshold){
		
		this->eyeCoordinates[2] = cubeLimitP.z - 1;
	}
	
	
	
	if(this->eyeCoordinates[0] <= cubeLimitN.x + theshold){
		
		this->eyeCoordinates[0] = cubeLimitN.x + 1;
	}
	
	if(this->eyeCoordinates[1] <= cubeLimitN.y+ theshold){
		
		this->eyeCoordinates[1] = cubeLimitN.y + 1;
	}
	
	if(this->eyeCoordinates[2] <= cubeLimitN.z+ theshold){
		
		this->eyeCoordinates[2] = cubeLimitN.z + 1;
	}

	
}

void Camera::setEyeCoordinate(int index,  GLfloat eye_coord){
	this->eyeCoordinates[index] = eye_coord;
}

void Camera::setObjCoordinate(int index,  GLfloat obj_coord){
	this->objectCoordinates[index] = obj_coord;
}


